<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Minecraft Dashboard</title>
  <link rel="stylesheet" href="/static/style.css">
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 2rem;
    }
    canvas {
      border: 1px solid #ccc;
      margin-top: 1rem;
    }
    button {
      margin: 0.5rem;
    }
  </style>
</head>
<body>
  <h1>Minecraft Dashboard</h1>
  <h3 id="status">Checking server status...</h3>

  <button onclick="startServer()">Start WebSocket Server</button>
  <button onclick="stopServer()">Stop WebSocket Server</button>

  <h2>Analyze Event Log</h2>
  <select id="fileSelect"></select>
  <button onclick="analyze()">Analyze</button>

  <h2>Player Movement Heatmap</h2>
  <canvas id="heatmap" width="500" height="500"></canvas>

  <script>

    // Maps a 0-1 intensity value to a blue â†’ red gradient
    function getHeatColor(intensity) {
      const r = Math.floor(255 * intensity);
      const g = Math.floor(255 * (1 - intensity) * 0.4);  // slight green for orange transition
      const b = Math.floor(255 * (1 - intensity));
      return `rgb(${r}, ${g}, ${b})`;
    }

    async function startServer() {
      const res = await fetch('/start-server', { method: 'POST' });
      const data = await res.json();
      alert(data.status);
    }

    async function stopServer() {
      const res = await fetch('/stop-server', { method: 'POST' });
      const data = await res.json();
      alert(data.status);
    }

    async function updateStatus() {
      const res = await fetch('/status');
      const data = await res.json();
      const el = document.getElementById('status');
      el.textContent = data.websocket_running
        ? 'ðŸŸ¢ WebSocket server is running'
        : 'ðŸ”´ WebSocket server is not running';
    }

    async function loadFiles() {
      const res = await fetch('/list-files');
      const data = await res.json();
      const select = document.getElementById('fileSelect');
      select.innerHTML = '';
      data.files.forEach(file => {
        const option = document.createElement('option');
        option.value = file;
        option.textContent = file;
        select.appendChild(option);
      });
    }

    async function analyze() {
      const filename = document.getElementById('fileSelect').value;
      if (!filename) return alert("Please select a file");
      const res = await fetch(`/analyze?file=${filename}`);
      const data = await res.json();
      const allPositions = Object.values(data.positions).flat();
      renderHeatmap(allPositions);
    }

    function renderHeatmap(positions) {
      const canvas = document.getElementById("heatmap");
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (positions.length === 0) {
        ctx.fillText("No movement data available", 20, 20);
        return;
      }

      const xs = positions.map(p => p[0]);
      const zs = positions.map(p => p[1]);
      const minX = Math.min(...xs);
      const maxX = Math.max(...xs);
      const minZ = Math.min(...zs);
      const maxZ = Math.max(...zs);

      const grid = {};
      positions.forEach(([x, z]) => {
        const key = `${x},${z}`;
        grid[key] = (grid[key] || 0) + 1;
      });

      const maxCount = Math.max(...Object.values(grid));
      const cellSize = 5;
      const padding = 40; // space for axis labels

      const plotWidth = canvas.width - padding;
      const plotHeight = canvas.height - padding;

      // Draw heatmap cells
      for (let key in grid) {
        const [x, z] = key.split(",").map(Number);
        const normX = ((x - minX) / (maxX - minX)) * plotWidth;
        const normZ = ((z - minZ) / (maxZ - minZ)) * plotHeight;

        const intensity = grid[key] / maxCount;
        const color = getHeatColor(intensity);

        ctx.fillStyle = color;
        ctx.fillRect(padding + normX, plotHeight - normZ, cellSize, cellSize);
      }

      // Draw axis
      ctx.strokeStyle = "#000";
      ctx.beginPath();
      ctx.moveTo(padding, 0);
      ctx.lineTo(padding, canvas.height - padding);
      ctx.lineTo(canvas.width, canvas.height - padding);
      ctx.stroke();

      // Axis labels
      ctx.fillStyle = "#000";
      ctx.font = "10px sans-serif";
      ctx.textAlign = "center";

      const steps = 5;
      for (let i = 0; i <= steps; i++) {
        const xVal = Math.round(minX + (i / steps) * (maxX - minX));
        const zVal = Math.round(minZ + (i / steps) * (maxZ - minZ));

        const xPos = padding + (i / steps) * plotWidth;
        const zPos = plotHeight - (i / steps) * plotHeight;

        // X axis ticks
        ctx.fillText(xVal, xPos, canvas.height - 5);

        // Z axis ticks
        ctx.fillText(zVal, padding - 20, zPos + 3);
      }

      // Axis titles
      ctx.save();
      ctx.fillText("X", canvas.width - 10, canvas.height - 10);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText("Z", -canvas.height / 2, 10);
      ctx.restore();
    }

    // Initial load
    setInterval(updateStatus, 3000);
    updateStatus();
    loadFiles();
  </script>
</body>
</html>